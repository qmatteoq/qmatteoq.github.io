---
id: 4552
title: 'App Studio: let&rsquo;s take a look at a generated project'
date: 2013-08-27T15:00:00+00:00
author: qmatteoq
layout: post
guid: http://wp.qmatteoq.com/?p=4552
permalink: /app-studio-lets-take-a-look-at-a-generated-project/
categories:
  - Windows Phone
tags:
  - App Studio
  - Windows Phone
---
In the previous post we‚Äôve seen how App Studio, the new tool by Microsoft, is able to generate a full Windows Phone application without having to write a single line of code. Anyway, even if the tool is very powerful, it doesn‚Äôt support every possible Windows Phone feature or scenario: for this reason, other than just downloading the XAP, you can also download the full Visual Studio project, so that you can edit and customize it.

In this post we‚Äôll see the structure of this project and how it works, so that you can understand how to add new views or new features. Let‚Äôs start to download the project from App Studio, using the link provided at the end of the creation process: for this post I‚Äôm going to use the Comics application I‚Äôve created in the previous post.

### The project

When you‚Äôll extract the compressed file you‚Äôve downloaded, you‚Äôll find a folder called **src,** which contains the real Visual Studio project.

[<img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-width: 0px;" title="image" alt="image" src="https://i0.wp.com/wp.qmatteoq.com/wp-content/uploads/2013/08/image_thumb12.png?resize=240%2C181" width="240" height="181" border="0" data-recalc-dims="1" />](https://i1.wp.com/wp.qmatteoq.com/wp-content/uploads/2013/08/image12.png)

Open the solution using the file **Solution.sln** with Visual Studio 2012 or 2013 Preview (since it‚Äôs a Windows Phone 8 project, it‚Äôs supported by both versions): you‚Äôll find that the application is made by 3 projects, splitted in various folders. It‚Äôs an application based on the Model-View-ViewModel pattern, which is the most famous development pattern in the XAML world.¬ I‚Äôve deeply talked about it in <a href="http://wp.qmatteoq.com/first-steps-with-caliburn-micro-in-windows-phone-8-the-complete-series/" target="_blank">my series of posts about Caliburn Micro</a>, which is one of the most popular MVVM frameworks. In this project, MVVM isn‚Äôt implemented using a specific toolkit or framework, but with custom classes that are built in the project. We‚Äôll see the details in the rest of the post. Another important thing to highlight is that the project uses **NuGet**: most of the third party libraries are installed using this tool, but to use it you have to make sure that, in the NuGet settings (right click on the project, choose **Mange NuGet packages** and then click on **Settings**) the option **Allow NuGet to download missing packages during the build** in the **Package restore** section is enabled. This step is required because the project is configured using the **Package restore** NuGet‚Äôs feature: basically, the project just contains a reference to the packages that have been installed, but the real packages‚Äô files are not included in the solution. They will be downloaded the first time the solution is built: this way, the size of the zip file generated by App Studio is reduced.

Here is how the solution looks like in Solution Explorer:

[<img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-width: 0px;" title="image" alt="image" src="https://i2.wp.com/wp.qmatteoq.com/wp-content/uploads/2013/08/image_thumb13.png?resize=240%2C239" width="240" height="239" border="0" data-recalc-dims="1" />](https://i2.wp.com/wp.qmatteoq.com/wp-content/uploads/2013/08/image13.png)

The folders contains various projects and files: the **UI** folder contains the real Windows Phone application (the one you‚Äôll need to launch on the emulator or on a device to test it), while the **Data** folder contains two other projects called **Entities** and **Repositories**, which take care of handling the application data. Let‚Äôs see them in details.

### Entities

This project contains all the classes that define the entities that are used in the app. You‚Äôll find some basic entities (for common scenarios, like RSS or Twitter feeds), plus an entity for every data source you‚Äôve defined in the web tool. For example, in my application I have a created a **ComicsCollection** (if you remember, it‚Äôs a collection to store a list of comics): the project will contain a class called **ComicsCollectionSchema**, which is the base class that identifies a comic (and that exposes the properties we‚Äôve defined when we‚Äôve created the data source columns in the visual editor).

As I‚Äôve already mentioned in the beginning of the post, the project generated by App Studio is built using the MVVM pattern: for this reason, every entity is defined to support this pattern, by implementing the **BindableBase** class. It‚Äôs a custom class built-in in the project, that offers an implementation of the **INotifyPropertyChanged** interface: it‚Äôs one the key concepts when you deal with binding, since it allows to propagate property changes to the user interface automatically. If you take a look at one of the entities‚Äô definition, you‚Äôll notice that the value of each property is set using a method called **SetProperty** : it takes care of storing the new value and to raise the **NotifyPropertyChanged** event, so that the control which is in binding is notified of the update. This way, you can simply connect a **ComicsCollectionSchema** object‚Äôs property defined in a ViewModel to a control in the View simply like this:

<pre class="brush: xml;">&lt;TextBlock Text="{Binding Path=Title}" /&gt;</pre>

Except for this, it‚Äôs a standard class that defines an entity: I have a property for every field, like **Title**, **Author** and **Description**.

Here is the code:

<pre class="brush: csharp;">public class ComicsCollectionSchema : BindableBase
{
    /// &lt;summary&gt;
    /// Identifier for instances created according ComicsCollectionSchema Data Schema.
    /// &lt;/summary&gt;
    public Guid Id { get; set; }

    private string _author;

    /// &lt;summary&gt;
    /// Gets/Sets value of Author column.
    /// &lt;/summary&gt;
    public string Author
    {
        get { return _author; }
        set
        {
            SetProperty(ref _author, value);
        }
    }

    private string _title;

    /// &lt;summary&gt;
    /// Gets/Sets value of Title column.
    /// &lt;/summary&gt;
    public string Title
    {
        get { return _title; }
        set
        {
            SetProperty(ref _title, value);
        }
    }

    private string _image;

    /// &lt;summary&gt;
    /// Gets/Sets value of Image column.
    /// &lt;/summary&gt;
    public string Image
    {
        get { return _image; }
        set
        {
            SetProperty(ref _image, value);
        }
    }

    private string _description;

    /// &lt;summary&gt;
    /// Gets/Sets value of Description column.
    /// &lt;/summary&gt;
    public string Description
    {
        get { return _description; }
        set
        {
            SetProperty(ref _description, value);
        }
    }
}</pre>

### Repositories

The project uses an approach based on repositories to make data available in the application. Like for entities, the project contains a repository for each data source we‚Äôve defined in the application: in this case, we‚Äôll find a class called **ComicsCollection**. This class acts as a middle man between the application and the data: the queries on data (in this case, to retrieve the comics list) aren‚Äôt performed directly by the ViewModel, but by the repository class, which exposes the basic methods to load and filter the available data set. The generated class will be different according if you‚Äôre using a static or dynamic collection: in the first case, you‚Äôll find a method called **GetData()** which takes care of initializing the data that has been defined in the web tool; in the second case, instead, it will provide the basic operations to query the dynamic service that has been generated with the application. Here is a sample of the second scenario:

<pre class="brush: csharp;">public class ComicsCollection : IComicsCollection 
{
    private readonly IJsonDataSource _jsonDataSource; 

    private const string DataServiceUrl = "http://dowapp.cloudapp.net/api/data?clientId={0}&appId={1}&datasourceName={2}";

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref="ComicsCollection" /&gt; class.
    /// &lt;/summary&gt;
    /// &lt;param name="jsonDataSource"&gt;A JSON based data source.&lt;/param&gt;
    public ComicsCollection(IJsonDataSource jsonDataSource)
    {
        _jsonDataSource = jsonDataSource;
    }

    /// &lt;summary&gt;
    /// Retrieves the data from a dynamic data service (URL specified in DataServiceUrl) , in an observable collection of ComicsCollectionSchema items.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;An observable collection of ComicsCollectionSchema items.&lt;/returns&gt;
    public async Task&lt;ObservableCollection&lt;ComicsCollectionSchema&gt;&gt; GetData()
    {            
        return await LoadData();
    } 

    private async Task&lt;ObservableCollection&lt;ComicsCollectionSchema&gt;&gt; LoadData()
    {
        var items = await _jsonDataSource.LoadRemote&lt;ComicsCollectionSchema[]&gt;(string.Format(DataServiceUrl, "1426","5b07b520-7b22-4756-97ae-4d92660afa17", "ComicsCollection"));
        return items != null ? new ObservableCollection&lt;ComicsCollectionSchema&gt;(items.OrderBy(i=&gt;i.Author)) : new ObservableCollection&lt;ComicsCollectionSchema&gt;();
    }
}</pre>

How does it work a dynamic data source, under the hood? It‚Äôs a REST service (which URL is set in the **DataServiceUrl** constant), which returns data using the JSON format.

The repository class uses a **JsonDataSource** class, which identifies a REST service that exchange data with the JSON format: the **LoadRemote<T>()** method (that is used in the **LoadData()** method) takes care of performing a network request and getting the data in JSON format from the service. Then, it‚Äôs able to automatically deserialize and convert it into a specific type, which is passed as **T** parameter: in this sample, the JSON data is converted into an array of **ComicsCollectionSchema** objects (which, if you remember, is the basic entity that defines a single comic). The method simply requires as parameter the URL of the service (that is combined with some fixed identifiers that are used to generate the unique URL) and return a collection of items, which is converted into an **ObservableCollection<T>()** to have built-in support to binding.

As you can see, every reporitory class implements an interface, which simply described the available methods. For example, the **ComicsCollection** class implements the following **IComicsCollection** interface:

<pre class="brush: csharp;">public interface IComicsCollection
{
    Task&lt;ObservableCollection&lt;ComicsCollectionSchema&gt;&gt; GetData();
}</pre>

We‚Äôll see later why this class is useful in the project‚Äôs ecosystem.

### The Windows Phone application

The biggest and most important project is the Windows Phone application, which contains many folders to organize the application structure. Since the application is built with the MVVM pattern, the two most important folders are **View** and **ViewModel**: the first one contains the application pages, which are the XAML files; the second one, instead, contains the ViewModels, which are the classes that define the interaction logic behind the view. In the **View** folder you‚Äôll find a view for every page defined in the web tool: in the comics application, there will be a page called **Comics_List.xaml** (which is the main page that contains a panorama control with the comics list) and one called **Comics_Detail.xaml** (which, instead, is the page that display the details about the selected comic). In the same way, in the **ViewModel** folder you‚Äôll find the two view models that are connected to the views: **Comics_ListViewModel** e **Comics_DetailViewModel.**

How Views and ViewModels are connected together? First we need to do a step back and to highlight that the whole project is based on the **dependency injection** approach: it means that basically every class of the project (including ViewModels) isn‚Äôt manually created, but it‚Äôs automatically resolved at runtime by a class called **dependency container.** What does it mean? Let‚Äôs explain it with a concrete example: we‚Äôve already seen that, to interact with the data, the project uses the repository approach, by offering a class called **ComicsCollection** that retrieves the data from the cloud service generated by the tool. This means that we can expect that, somewhere in the ViewModel of the main application page, the class creates a new **ComicsCollection** object and calls the **GetData()** method to populate the list:

<pre class="brush: csharp;">public async void RefreshComics()
{
   ComicsCollection collection = new ComicsCollection();
   await collection.GetData();
}</pre>

Which is the problem of this approach in a complex application? That if we need to swap the data source (for example, because we‚Äôre in testing stage and, instead of using real data from the service, we want to use fake data), we need to change every point in the application in which we‚Äôve created a new instance of the **ComicsCollection** class. Dependancy injection, instead, allows to specify in one single point (tipically, when the application starts) which concrete implementation we want to use when we require to work with a class. This is why the **ComicsCollection** class implements an **IComicsCollection** interface: we can register, in the dependency container, which implementation we want to use for that interface. The App Studio projects uses **Unity** (which is <a href="http://unity.codeplex.com/" target="_blank">an open source project by Microsoft</a>) to support dependency injection: you can see its implementation in the **Ioc** folder, which contains a class called **Container:** its purpose is to register all the application classes. As you can see in the class constructor, by using the **RegisterType<T, Y>()** method of the **UnityContainer** class, the application specifies, for every interface, which is the concrete implementation to use (the **T** parameter is the interface, the **Y** one is the implementation). Here is a sample implementation:

<pre class="brush: csharp;">public Container()
{
    _currentContainer = new UnityContainer();

    _currentContainer.RegisterType&lt;ILiveTileService, LiveTileService&gt;();
    _currentContainer.RegisterType&lt;ILockScreenService, LockScreenService&gt;();
    _currentContainer.RegisterType&lt;IDialogService, DialogService&gt;();
    _currentContainer.RegisterType&lt;IReminderService, ReminderService&gt;();
    _currentContainer.RegisterType&lt;IShareService, ShareService&gt;();
    _currentContainer.RegisterType&lt;ISpeechService, SpeechService&gt;();
    _currentContainer.RegisterType&lt;INavigationService, NavigationService&gt;();
    _currentContainer.RegisterType&lt;IJsonDataSource, JsonDataSource&gt;();
    _currentContainer.RegisterType&lt;IXmlDataSource, XmlDataSource&gt;();
    _currentContainer.RegisterType&lt;IYoutubeDataSource, YoutubeDataSource&gt;();

    _currentContainer.RegisterType&lt;IComics_ListViewModel, Comics_ListViewModel&gt;();
    _currentContainer.RegisterType&lt;IComics_DetailViewModel, Comics_DetailViewModel&gt;();

    if (!System.ComponentModel.DesignerProperties.IsInDesignTool)
    {
        _currentContainer.RegisterType&lt;IComicsCollection, ComicsCollection&gt;(new ContainerControlledLifetimeManager());
    }
    else
    {
        _currentContainer.RegisterType&lt;IComicsCollection, FakeComicsCollection&gt;(new ContainerControlledLifetimeManager());
    }    
}</pre>

The application simply registers in the bootstrapper every available service and view model: it‚Äôs important to keep an eye on this class; if we want to add new pages or new services to the application, we‚Äôll have to register them in this place. We can see also a sample of the scenario I‚Äôve previously described: if the user is working with a page that uses the **ComicsCollection** class in the Visual Studio or Blend designer, it uses an implementation with fake data called **FakeComicsCollection**; otherwise, it uses the real one that gets data from the cloud service.

You can also see, that others than View and ViewModels, the application uses the concepts of **services**: basically, they are classes which takes care of satisfying a specific scenario and that are stored inside the **Services** folder. Instead of writing the code to perform a task directly in the ViewModel, it‚Äôs defined in a separate class, which is a service: then, in the ViewModel, we interact with this class to perform our operation. You can see, for example, that we have a **LiveTileService**, which exposes methods to create secondary tiles or to update them; a **LockScreenService**, to set an image as lock screen background; a **ShareService**, to support sharing on social network. One of the most important (that we‚Äôll cover in the next post) is **NavigationService**, which can be used to manage navigation between different pages directly in the ViewModel.

Now that we‚Äôve seen how classes are registered,¬ a question may arise: how are they resolved and used in a ViewModel? The most common way is completely automatic: it‚Äôs enough to declare the interface of the class we want to use as parameter of the public constructor. Since both the interface and the ViewModel are registered in the container, Unity will automatically resolve them. To see an example, open any ViewModel of the application: here is a sample of the first lines of code.

<pre class="brush: csharp;">public partial class Comics_ListViewModel : BindableBase, IComics_ListViewModel
{       
     private readonly IDialogService _dialogService;
     private readonly INavigationService _navigationService;
     private readonly ILockScreenService _lockScreenService;
     private readonly IComicsCollection _comicsCollection;

     public Comics_ListViewModel(IDialogService dialogService, INavigationService navigationService, ILockScreenService lockScreenService, IComicsCollection comicsCollection)
     {
         _dialogService = dialogService;
         _navigationService = navigationService;
         _lockScreenService = lockScreenService;
         _comicsCollection = comicsCollection;
     }
}</pre>

As you can see, the public constructor of the ViewModel includes a parameter for every service and class that it needs to use: automagically, every interface will be ‚Äúinjected‚Äù (thus, the dependency injection name) with the concrete implementation declared in the container. This way, we‚Äôll be able to use our services and classes without having to create a new instance each time. For example, the sample usage of the **ComicsCollection** class we‚Äôve previously seen can be converted simply in:

<pre class="brush: csharp;">public async void RefreshComics() 
{
    await _comicsCollection.GetData();
}</pre>

Is there another way to resolve a class using dependency injection? Yes, and we can introduce it by speaking about how Views and ViewModels are connected together in the Windows Phone project. The used approach is called **ViewModelLocator**, which is a class that acts as a middle man between the Views and the ViewModels: it simply exposes every ViewModel as a property, which is, in the end, defined as **DataContext** of every view. You can find the ViewModelLocator implementation in the **Services** folder and it‚Äôs called **ViewModelLocatorService.** This service offers a sample of another way to get a reference to a class using dependency injection:

<pre class="brush: csharp;">public class ViewModelLocatorService
{
    // IoC container
    private readonly IContainer _container;

    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref="ViewModelLocatorService" /&gt; class.
    /// &lt;/summary&gt;
    public ViewModelLocatorService()
    {
        _container = new Container();
    }

    /// &lt;summary&gt;
    /// Gets the reference to a Comics_ListViewModel.
    /// &lt;/summary&gt;
    public IComics_ListViewModel Comics_ListViewModel
    {
        get { return _container.Resolve&lt;Comics_ListViewModel&gt;(); }
    }

    /// &lt;summary&gt;
    /// Gets the reference to a Comics_DetailViewModel.
    /// &lt;/summary&gt;
    public IComics_DetailViewModel Comics_DetailViewModel
    {
        get { return _container.Resolve&lt;Comics_DetailViewModel&gt;(); }
    }
}</pre>

As you can see, we have a public property for each ViewModel: if we want to add new pages to our application, we should keep an eye also on this class, since we‚Äôll have to add a new property for every view. And here comes the manual usage of the dependency injection‚Äôs container: since, in this case, we can‚Äôt resolve the class automatically (we explicity need to create a new instance of the ViewModel) we ask to the container for the instance that has been registed at startup using the **Resolve<T>** method, where **T** is the ViewModel‚Äôs type we want to require. This way, since we‚Äôre not manually creating a new instance but we‚Äôre asking to the container to get the registered one, all the ViewModel‚Äôs dependencies (remember all the services and classes that we‚Äôve added as parameters of the ViewModel‚Äôs public constructor?) will be automatically satisfied.

In the end, the **ViewModelLocatorService** class is exposed by the application as global resource, so we can interact with it directly from XAML and assign every ViewModel to every View. If you open the **App.xaml** file you‚Äôll see that the class is registered in the resources section:

<pre class="brush: xml;">&lt;Application.Resources&gt;
    &lt;sys:String x:Key="AppName"&gt;Comics Tracker beta&lt;/sys:String&gt;

    &lt;!-- ViewModel locator --&gt;
    &lt;services:ViewModelLocatorService x:Key="ViewModelLocator"/&gt;       
&lt;/Application.Resources&gt;</pre>

If you open any View of the application, you‚Äôll see that the **DataContext** property of the page is assigned to its specific ViewModel thanks to the **ViewModelLocator** resource we‚Äôve previously defined:

<pre class="brush: xml;">&lt;phone:PhoneApplicationPage 
x:Class="WPAppStudio.View.Comics_List"
DataContext="{Binding Path=Comics_ListViewModel, Source={StaticResource ViewModelLocator}}"&gt;

&lt;!-- content of the page --&gt;

&lt;/phone:PhoneApplicationPage&gt;</pre>

### It was a long ride

Yeah, it‚Äôs been a long ride: the project generated by Visual Studio can be complex and scary, especially if you aren‚Äôt an experienced Windows Phone developer, so it took a while to explain how things are working. In the next post, we‚Äôll see how to start customizing our poject to add new pages and new data source. Stay tuned!